{"version":3,"sources":["definitions/ApiNamespace.ts"],"names":[],"mappings":"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","file":"definitions/ApiNamespace.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* tslint:disable:no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\nimport ApiModuleVariable from './ApiModuleVariable';\r\nimport ApiItem, { ApiItemKind, IApiItemOptions } from './ApiItem';\r\nimport ApiItemContainer from './ApiItemContainer';\r\nimport { IExportedSymbol } from '../IExportedSymbol';\r\nconst allowedTypes: string[] = ['string', 'number', 'boolean'];\r\n\r\n/**\r\n  * This class is part of the ApiItem abstract syntax tree. It represents exports of\r\n  * a namespace, the exports can be module variable constants of type \"string\", \"boolean\" or \"number\".\r\n  * An ApiNamespace is defined using TypeScript's \"namespace\" keyword.\r\n  *\r\n  * @remarks A note about terminology:\r\n  * - EcmaScript \"namespace modules\" are not conventional namespaces; their semantics are\r\n  * more like static classes in C# or Java.\r\n  * - API Extractor's support for namespaces is currently limited to representing tables of\r\n  * constants, and has a benefit of enabling WebPack to avoid bundling unused values.\r\n  * - We currently still recommend to use static classes for utility libraries, since this\r\n  * provides getters/setters, public/private, and some other structure missing from namespaces.\r\n  */\r\nexport default class ApiNamespace extends ApiItemContainer {\r\n  private _exportedNormalizedSymbols: IExportedSymbol[] = [];\r\n\r\n  constructor(options: IApiItemOptions) {\r\n    super(options);\r\n    this.kind = ApiItemKind.Namespace;\r\n    this.name = options.declarationSymbol.name;\r\n\r\n    const exportSymbols: ts.Symbol[] = this.typeChecker.getExportsOfModule(this.declarationSymbol);\r\n    if (exportSymbols) {\r\n      for (const exportSymbol of exportSymbols) {\r\n        const followedSymbol: ts.Symbol = this.followAliases(exportSymbol);\r\n\r\n        if (!followedSymbol.declarations) {\r\n          // This is an API Extractor bug, but it could happen e.g. if we upgrade to a new\r\n          // version of the TypeScript compiler that introduces new AST variations that we\r\n          // haven't tested before.\r\n          this.reportWarning(`The definition \"${exportSymbol.name}\" has no declarations`);\r\n          continue;\r\n        }\r\n\r\n        if (!(followedSymbol.flags === ts.SymbolFlags.BlockScopedVariable)) {\r\n          this.reportWarning(`Unsupported export \"${exportSymbol.name}\" ` +\r\n            'Currently the \"namespace\" block only supports constant variables.');\r\n          continue;\r\n        }\r\n\r\n        // Since we are imposing that the items within a namespace be\r\n        // const properties we are only taking the first declaration.\r\n        // If we decide to add support for other types within a namespace\r\n        // we will have for evaluate each declaration.\r\n        const declaration: ts.Declaration = followedSymbol.getDeclarations()[0];\r\n\r\n        if (declaration.parent.flags !== ts.NodeFlags.Const) {\r\n          this.reportWarning(`Export \"${exportSymbol.name}\" is missing the \"const\" ` +\r\n            'modifier. Currently the \"namespace\" block only supports constant variables.');\r\n          continue;\r\n        }\r\n\r\n        const propertySignature: ts.PropertySignature = declaration as ts.PropertySignature;\r\n        if (!propertySignature.type || allowedTypes.indexOf(propertySignature.type.getText()) < 0) {\r\n          this.reportWarning(`Export \"${exportSymbol.name}\" must specify and be of type` +\r\n            '\"string\", \"number\" or \"boolean\"');\r\n          continue;\r\n        }\r\n\r\n        if (!propertySignature.initializer) {\r\n          this.reportWarning(`Export \"${exportSymbol.name}\" must have an initialized value`);\r\n          continue;\r\n        }\r\n\r\n        // Typescript's VariableDeclaration AST nodes have an VariableDeclarationList parent,\r\n        // and the VariableDeclarationList exists within a VariableStatement, which is where\r\n        // the JSDoc comment Node can be found.\r\n        // If there is no parent or grandparent of this VariableDeclartion then\r\n        // we do not know how to obtain the JSDoc comment.\r\n        let jsdocNode: ts.Node;\r\n        if (!declaration.parent || !declaration.parent.parent ||\r\n          declaration.parent.parent.kind !== ts.SyntaxKind.VariableStatement) {\r\n          this.reportWarning(`Unable to locate the documentation node for \"${exportSymbol.name}\"; `\r\n            + `this may be an API Extractor bug`);\r\n        } else {\r\n          jsdocNode = declaration.parent.parent;\r\n        }\r\n\r\n        const exportMemberOptions: IApiItemOptions = {\r\n          extractor: this.extractor,\r\n          declaration,\r\n          declarationSymbol: followedSymbol,\r\n          jsdocNode: jsdocNode,\r\n          exportSymbol\r\n        };\r\n\r\n        this.addMemberItem(new ApiModuleVariable(exportMemberOptions));\r\n\r\n        this._exportedNormalizedSymbols.push({\r\n          exportedName: exportSymbol.name,\r\n          followedSymbol: followedSymbol\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}