{"version":3,"sources":["TestFileComparer.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,6BAA8B;AAC9B,uBAAyB;AAEzB,uFAAuF;AAEvF;IAAA;IA4CA,CAAC;IA1Ce,0CAAyB,GAAvC,UAAwC,cAAsB,EAAE,gBAAwB;QACtF,IAAM,aAAa,GAAW,EAAE,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC/E,IAAM,eAAe,GAAW,EAAE,CAAC,YAAY,CAAC,gBAAgB,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAEnF,aAAM,CAAC,IAAI,CAAC,yBAAyB,CAAC,aAAa,EAAE,eAAe,CAAC,EACnE,qDAAqD;cACnD,cAAc,GAAG,gBAAgB;cACjC,YAAY,GAAG,cAAc,CAAC,CAAC;IACrC,CAAC;IAED;;;;;;OAMG;IACW,0CAAyB,GAAvC,UAAwC,iBAAyB,EAAE,mBAA2B;QAC5F,wCAAwC;QACxC,IAAM,gBAAgB,GAAW,iBAAiB,CAAC,OAAO,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QAC1E,IAAM,kBAAkB,GAAW,mBAAmB,CAAC,OAAO,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QAC9E,MAAM,CAAC,gBAAgB,KAAK,kBAAkB,CAAC;IACjD,CAAC;IAED;;;;OAIG;IACW,0BAAS,GAAvB,UAAwB,cAAsB,EAAE,KAAa;QAC3D,IAAM,WAAW,GAAW,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAC5D,EAAE,CAAC,aAAa,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;IAChD,CAAC;IAEa,oCAAmB,GAAjC,UAAkC,KAAa;QAC7C,oBAAoB;QACpB,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACX,MAAM,IAAI,KAAK,CAAC,uCAAqC,KAAO,CAAC,CAAC;QAChE,CAAC;QACD,IAAM,WAAW,GAAW,KAAK,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QACvE,MAAM,CAAC,WAAW,CAAC;IACrB,CAAC;IACH,uBAAC;AAAD,CA5CA,AA4CC,IAAA","file":"TestFileComparer.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { assert } from 'chai';\r\nimport * as fs from 'fs';\r\n\r\n/* tslint:disable:no-function-expression - Mocha uses a poorly scoped \"this\" pointer */\r\n\r\nexport default class TestFileComparer {\r\n\r\n  public static assertFileMatchesExpected(actualFilename: string, expectedFilename: string): void {\r\n    const actualContent: string = fs.readFileSync(actualFilename).toString('utf8');\r\n    const expectedContent: string = fs.readFileSync(expectedFilename).toString('utf8');\r\n\r\n    assert(this.areEquivalentFileContents(actualContent, expectedContent),\r\n      'The file content does not match the expected value:'\r\n      + '\\nEXPECTED: ' + expectedFilename\r\n      + '\\nACTUAL: ' + actualFilename);\r\n  }\r\n\r\n  /**\r\n   * Compares the contents of two files, and returns true if they are equivalent.\r\n   * Note that these files are not normally edited by a human; the \"equivalence\"\r\n   * comparison here is intended to ignore spurious changes that might be introduced\r\n   * by a tool, e.g. Git newline normalization or an editor that strips\r\n   * whitespace when saving.\r\n   */\r\n  public static areEquivalentFileContents(actualFileContent: string, expectedFileContent: string): boolean {\r\n    // NOTE: \"\\s\" also matches \"\\r\" and \"\\n\"\r\n    const normalizedActual: string = actualFileContent.replace(/[\\s]+/g, ' ');\r\n    const normalizedExpected: string = expectedFileContent.replace(/[\\s]+/g, ' ');\r\n    return normalizedActual === normalizedExpected;\r\n  }\r\n\r\n  /**\r\n   * Generates the report and writes it to disk.\r\n   * @param reportFilename - The output filename\r\n   * @param value - A string value to be written to file.\r\n   */\r\n  public static writeFile(reportFilename: string, value: string): void {\r\n    const fileContent: string = this.generateFileContent(value);\r\n    fs.writeFileSync(reportFilename, fileContent);\r\n  }\r\n\r\n  public static generateFileContent(value: string): string {\r\n    // Normalize to CRLF\r\n    if (!value) {\r\n      throw new Error(`Expected non undefined parameter: ${value}`);\r\n    }\r\n    const fileContent: string = value.toString().replace(/\\r?\\n/g, '\\r\\n');\r\n    return fileContent;\r\n  }\r\n}"],"sourceRoot":"..\\src"}