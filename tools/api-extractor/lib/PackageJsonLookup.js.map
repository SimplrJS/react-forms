{"version":3,"sources":["PackageJsonLookup.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,0CAA0C;AAE1C,8BAAgC;AAChC,2BAA6B;AAC7B,uCAAkC;AASlC;;;GAGG;AACH;IASE;QACE,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAA8B,CAAC;QACjE,IAAI,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAkB,CAAC;IACrD,CAAC;IAED;;;;;;;OAOG;IACI,qDAAyB,GAAhC,UAAiC,cAAsB;QACrD,iFAAiF;QACjF,wBAAwB;QACxB,EAAE,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;YACjD,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QACtD,CAAC;QAED,IAAI,MAA0B,CAAC;QAE/B,IAAM,YAAY,GAAW,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;QAC1D,EAAE,CAAC,CAAC,CAAC,YAAY,IAAI,YAAY,KAAK,cAAc,CAAC,CAAC,CAAC;YACrD,MAAM,GAAG,SAAS,CAAC;QACrB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;YACnE,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;QACxC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,GAAG,IAAI,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC;QACxD,CAAC;QAED,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM,CAAC,CAAC;QACrD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;OAMG;IACI,2CAAe,GAAtB,UAAuB,eAAuB;QAC5C,IAAI,MAAM,GAAW,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;QACjE,EAAE,CAAC,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC;YACzB,MAAM,CAAC,MAAM,CAAC;QAChB,CAAC;QAED,IAAM,WAAW,GAAiB,kBAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,cAAc,CAAC,CAAiB,CAAC;QACpH,MAAM,GAAG,WAAW,CAAC,IAAI,CAAC;QAE1B,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;QACpD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IACH,wBAAC;AAAD,CA/DA,AA+DC,IAAA","file":"PackageJsonLookup.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* tslint:disable:no-constant-condition */\r\n\r\nimport * as fsx from 'fs-extra';\r\nimport * as path from 'path';\r\nimport JsonFile from './JsonFile';\r\n\r\n/**\r\n * Represents a package.json file.\r\n */\r\ninterface IPackageJson {\r\n  name: string;\r\n}\r\n\r\n/**\r\n * This class provides methods for finding the nearest \"package.json\" for a folder\r\n * and retrieving the name of the package.  The results are cached.\r\n */\r\nexport default class PackageJsonLookup {\r\n  // Cached the return values for tryFindPackagePathUpwards():\r\n  // sourceFilePath --> packageJsonFolder\r\n  private _packageFolderCache: Map<string, string | undefined>;\r\n\r\n  // Cached the return values for readPackageName():\r\n  // packageJsonPath --> packageName\r\n  private _packageNameCache: Map<string, string>;\r\n\r\n  constructor() {\r\n    this._packageFolderCache = new Map<string, string | undefined>();\r\n    this._packageNameCache = new Map<string, string>();\r\n  }\r\n\r\n  /**\r\n   * Finds the path to the package folder of a given currentPath, by probing\r\n   * upwards from the currentPath until a package.json file is found.\r\n   * If no package.json can be found, undefined is returned.\r\n   *\r\n   * @param currentPath - a path (relative or absolute) of the current location\r\n   * @returns a relative path to the package folder\r\n   */\r\n  public tryFindPackagePathUpwards(sourceFilePath: string): string | undefined {\r\n    // Two lookups are required, because get() cannot distinguish the undefined value\r\n    // versus a missing key.\r\n    if (this._packageFolderCache.has(sourceFilePath)) {\r\n      return this._packageFolderCache.get(sourceFilePath);\r\n    }\r\n\r\n    let result: string | undefined;\r\n\r\n    const parentFolder: string = path.dirname(sourceFilePath);\r\n    if (!parentFolder || parentFolder === sourceFilePath) {\r\n      result = undefined;\r\n    } else if (fsx.existsSync(path.join(parentFolder, 'package.json'))) {\r\n      result = path.normalize(parentFolder);\r\n    } else {\r\n      result = this.tryFindPackagePathUpwards(parentFolder);\r\n    }\r\n\r\n    this._packageFolderCache.set(sourceFilePath, result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Loads the package.json file and returns the name of the package.\r\n   *\r\n   * @param packageJsonPath - an absolute path to the folder containing the\r\n   * package.json file, it does not include the 'package.json' suffix.\r\n   * @returns the name of the package (E.g. @microsoft/api-extractor)\r\n   */\r\n  public readPackageName(packageJsonPath: string): string {\r\n    let result: string = this._packageNameCache.get(packageJsonPath);\r\n    if (result !== undefined) {\r\n      return result;\r\n    }\r\n\r\n    const packageJson: IPackageJson = JsonFile.loadJsonFile(path.join(packageJsonPath, 'package.json')) as IPackageJson;\r\n    result = packageJson.name;\r\n\r\n    this._packageNameCache.set(packageJsonPath, result);\r\n    return result;\r\n  }\r\n}\r\n"],"sourceRoot":"..\\src"}