{"version":3,"sources":["DocElementParser.ts"],"names":[],"mappings":"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","file":"DocElementParser.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { ITextElement, IDocElement, IHrefLinkElement, ICodeLinkElement, ISeeDocElement } from './IDocElement';\r\nimport ApiDefinitionReference from './ApiDefinitionReference';\r\nimport ApiDocumentation from './definitions/ApiDocumentation';\r\nimport { ApiItemKind } from './definitions/ApiItem';\r\nimport Token, { TokenType } from './Token';\r\nimport Tokenizer from './Tokenizer';\r\nimport ResolvedApiItem from './ResolvedApiItem';\r\n\r\nexport default class DocElementParser {\r\n  /**\r\n   * Used to validate the display text for an \\@link tag.  The display text can contain any\r\n   * characters except for certain AEDoc delimiters: \"@\", \"|\", \"{\", \"}\".\r\n   * This RegExp matches the first bad character.\r\n   * Example: \"Microsoft's {spec}\" --> \"{\"\r\n   */\r\n  private static _displayTextBadCharacterRegEx: RegExp = /[@|{}]/;\r\n\r\n  /**\r\n   * Matches a href reference. This is used to get an idea whether a given reference is for an href\r\n   * or an API definition reference.\r\n   *\r\n   * For example, the following would be matched:\r\n   * 'http://'\r\n   * 'https://'\r\n   *\r\n   * The following would not be matched:\r\n   * '@microsoft/sp-core-library:Guid.newGuid'\r\n   * 'Guid.newGuid'\r\n   * 'Guid'\r\n   */\r\n  private static _hrefRegEx: RegExp = /^[a-z]+:\\/\\//;\r\n\r\n  public static getAsText(collection: IDocElement[], reportError: (message: string) => void): string {\r\n    let text: string = '';\r\n\r\n    collection.forEach(docElement => {\r\n      switch (docElement.kind) {\r\n        case 'textDocElement':\r\n          text += `${(docElement as ITextElement).value} `;\r\n          break;\r\n        case 'linkDocElement':\r\n          // links don't count towards the summary\r\n          break;\r\n        case 'seeDocElement':\r\n          // see doesn't count towards the summary\r\n          break;\r\n        default:\r\n          reportError('Unexpected item in IDocElement collection');\r\n          break;\r\n      }\r\n    });\r\n\r\n    return text.trim();\r\n  }\r\n\r\n  public static makeTextElement(text: string): IDocElement {\r\n    if (!text) {\r\n      return;\r\n    }\r\n    return {kind: 'textDocElement', value: text} as ITextElement;\r\n  }\r\n\r\n  public static parse(documentation: ApiDocumentation, tokenizer: Tokenizer): IDocElement[] {\r\n    const docElements: IDocElement[] = [];\r\n    let parsing: boolean = true;\r\n    let token: Token;\r\n\r\n    while (parsing) {\r\n      token = tokenizer.peekToken();\r\n      if (!token) {\r\n        parsing = false; // end of stream\r\n        break;\r\n      }\r\n\r\n      if (token.type === TokenType.BlockTag) {\r\n        switch (token.tag) {\r\n          case '@see':\r\n            tokenizer.getToken();\r\n            docElements.push({\r\n              kind: 'seeDocElement',\r\n              seeElements: this.parse(documentation, tokenizer)\r\n            } as ISeeDocElement);\r\n            break;\r\n          default:\r\n            parsing = false; // end of summary tokens\r\n            break;\r\n        }\r\n      } else if (token.type === TokenType.InlineTag) {\r\n        switch (token.tag) {\r\n          case '@inheritdoc':\r\n            tokenizer.getToken();\r\n            if (docElements.length > 0 ||  documentation.summary.length > 0) {\r\n              documentation.reportError('A summary block is not allowed here,'\r\n                + ' because the @inheritdoc target provides the summary');\r\n            }\r\n            documentation.incompleteInheritdocs.push(token);\r\n            documentation.isDocInherited = true;\r\n            break;\r\n          case '@link' :\r\n            const linkDocElement: ICodeLinkElement | IHrefLinkElement = this.parseLinkTag(documentation, token);\r\n            if (linkDocElement) {\r\n              // Push to docElements to retain position in the documentation\r\n              docElements.push(linkDocElement);\r\n              if (linkDocElement.referenceType === 'code') {\r\n                documentation.incompleteLinks.push(linkDocElement);\r\n              }\r\n            }\r\n            tokenizer.getToken(); // get the link token\r\n            break;\r\n          default:\r\n            parsing = false;\r\n            break;\r\n        }\r\n      } else if (token.type === TokenType.Text) {\r\n        docElements.push({kind: 'textDocElement', value: token.text} as ITextElement);\r\n          tokenizer.getToken();\r\n      } else {\r\n        documentation.reportError(`Unidentifiable Token ${token.type} ${token.tag} \"${token.text}\"`);\r\n      }\r\n    }\r\n    return docElements;\r\n  }\r\n\r\n  /**\r\n   * This method parses the semantic information in an \\@link JSDoc tag, creates and returns a\r\n   * linkDocElement with the corresponding information. If the corresponding inline tag \\@link is\r\n   * not formatted correctly an error will be reported.\r\n   *\r\n   * The format for the \\@link tag is {\\@link URL or API defintion reference | display text}, where\r\n   * the '|' is only needed if the optional display text is given.\r\n   *\r\n   * Examples:\r\n   * \\{@link http://microsoft.com | microsoft home \\}\r\n   * \\{@link http://microsoft.com \\}\r\n   * \\{@link @microsoft/sp-core-library:Guid.newGuid | new Guid Object \\}\r\n   * \\{@link @microsoft/sp-core-library:Guid.newGuid \\}\r\n   */\r\n  public static parseLinkTag(documentation: ApiDocumentation, tokenItem: Token): IHrefLinkElement | ICodeLinkElement {\r\n    if (!tokenItem.text) {\r\n      documentation.reportError('The {@link} tag must include a URL or API item reference');\r\n       return;\r\n    }\r\n\r\n    // Make sure there are no extra pipes\r\n    const pipeSplitContent: string[] = tokenItem.text.split('|').map(value => {\r\n      if (value) {\r\n        return value.trim();\r\n      }\r\n    });\r\n    if (pipeSplitContent.length > 2) {\r\n      documentation.reportError('The {@link} tag contains more than one pipe character (\"|\")');\r\n      return undefined;\r\n    }\r\n\r\n    const addressPart: string = pipeSplitContent[0];\r\n    const displayTextPart: string = pipeSplitContent.length > 1 ? pipeSplitContent[1] : '';\r\n\r\n    // Try to guess if the tokenContent is a link or API definition reference\r\n    let linkDocElement: ICodeLinkElement | IHrefLinkElement;\r\n    if (this._hrefRegEx.test(addressPart)) {\r\n      // Make sure only a single URL is given\r\n      if (addressPart.indexOf(' ') >= 0) {\r\n        documentation.reportError('The {@link} tag contains additional spaces after the URL;'\r\n          + ' if the URL contains spaces, encode them using %20; for display text, use a pipe delimiter (\"|\")');\r\n        return undefined;\r\n      }\r\n\r\n      linkDocElement = {\r\n        kind: 'linkDocElement',\r\n        referenceType: 'href',\r\n        targetUrl: addressPart\r\n        // (\"value\" will be assigned below)\r\n      };\r\n\r\n    } else {\r\n      // we are processing an API definition reference\r\n      const apiDefitionRef: ApiDefinitionReference = ApiDefinitionReference.createFromString(\r\n        addressPart,\r\n        documentation.reportError\r\n      );\r\n\r\n      // Once we can locate local API definitions, an error should be reported here if not found.\r\n      if (!apiDefitionRef) {\r\n        return undefined;\r\n      }\r\n\r\n      linkDocElement = {\r\n        kind: 'linkDocElement',\r\n        referenceType: 'code',\r\n        scopeName: apiDefitionRef.scopeName,\r\n        packageName: apiDefitionRef.packageName,\r\n        exportName: apiDefitionRef.exportName,\r\n        memberName: apiDefitionRef.memberName\r\n        // (\"value\" will be assigned below)\r\n      };\r\n    }\r\n\r\n    // If a display name is given, ensure it only contains characters for words.\r\n    if (displayTextPart) {\r\n      const match: RegExpExecArray | undefined = this._displayTextBadCharacterRegEx.exec(displayTextPart);\r\n      if (match) {\r\n        documentation.reportError(`The {@link} tag\\'s display text contains an unsupported`\r\n          + ` character: \"${match[0]}\"`);\r\n        return undefined;\r\n      }\r\n      // Full match is valid text\r\n      linkDocElement.value = displayTextPart;\r\n    } else {\r\n      // If the display text is not explicitly provided, then use the address as the display text\r\n      linkDocElement.value = addressPart;\r\n    }\r\n\r\n    return linkDocElement;\r\n  }\r\n\r\n  /**\r\n   * This method parses the semantic information in an \\@inheritdoc JSDoc tag and sets\r\n   * all the relevant documenation properties from the inherited doc onto the documenation\r\n   * of the current api item.\r\n   *\r\n   * The format for the \\@inheritdoc tag is {\\@inheritdoc scopeName/packageName:exportName.memberName}.\r\n   * For more information on the format see IInheritdocRef.\r\n   */\r\n  public static parseInheritDoc(documentation: ApiDocumentation, token: Token, warnings: string[]): void {\r\n\r\n    // Check to make sure the API definition reference is at most one string\r\n    const tokenChunks: string[] = token.text.split(' ');\r\n    if (tokenChunks.length > 1) {\r\n      documentation.reportError('The {@inheritdoc} tag does not match the expected pattern' +\r\n        ' \"{@inheritdoc @scopeName/packageName:exportName}\"');\r\n      return;\r\n    }\r\n\r\n    // Create the IApiDefinitionReference object\r\n    // Deconstruct the API reference expression 'scopeName/packageName:exportName.memberName'\r\n    const apiDefinitionRef: ApiDefinitionReference = ApiDefinitionReference.createFromString(\r\n      token.text,\r\n      documentation.reportError\r\n    );\r\n    // if API reference expression is formatted incorrectly then apiDefinitionRef will be undefined\r\n    if (!apiDefinitionRef) {\r\n      documentation.reportError(`Incorrectly formatted API item reference: \"${token.text}\"`);\r\n      return;\r\n    }\r\n\r\n    // Atempt to locate the apiDefinitionRef\r\n    const resolvedApiItem: ResolvedApiItem = documentation.referenceResolver.resolve(\r\n      apiDefinitionRef,\r\n      documentation.extractor.package,\r\n      warnings\r\n    );\r\n\r\n    // If no resolvedApiItem found then nothing to inherit\r\n    // But for the time being set the summary to a text object\r\n    if (!resolvedApiItem) {\r\n      const textDocItem: IDocElement = {\r\n        kind: 'textDocElement',\r\n        value: `See documentation for ${tokenChunks[0]}`\r\n      } as ITextElement;\r\n      documentation.summary = [textDocItem];\r\n      return;\r\n    }\r\n\r\n    // We are going to copy the resolvedApiItem's documentation\r\n    // We must make sure it's documentation can be completed,\r\n    // if we cannot, an error will be reported viathe documentation error handler.\r\n    // This will only be the case our resolvedApiItem was created from a local\r\n    // ApiItem. Resolutions from JSON will have an undefined 'apiItem' property.\r\n    // Example: a circular reference will report an error.\r\n    if (resolvedApiItem.apiItem) {\r\n      resolvedApiItem.apiItem.completeInitialization();\r\n    }\r\n\r\n    // inheritdoc found, copy over IDocBase properties\r\n    documentation.summary =  resolvedApiItem.summary;\r\n    documentation.remarks = resolvedApiItem.remarks;\r\n\r\n    // Copy over detailed properties if neccessary\r\n    // Add additional cases if needed\r\n    switch (resolvedApiItem.kind) {\r\n      case ApiItemKind.Function:\r\n        documentation.parameters = resolvedApiItem.params;\r\n        documentation.returnsMessage = resolvedApiItem.returnsMessage;\r\n        break;\r\n      case ApiItemKind.Method:\r\n        documentation.parameters = resolvedApiItem.params;\r\n        documentation.returnsMessage = resolvedApiItem.returnsMessage;\r\n        break;\r\n    }\r\n\r\n    // Check if inheritdoc is depreacted\r\n    // We need to check if this documentation has a deprecated message\r\n    // but it may not appear until after this token.\r\n    if (resolvedApiItem.deprecatedMessage.length > 0) {\r\n      documentation.isDocInheritedDeprecated = true;\r\n    }\r\n  }\r\n}"],"sourceRoot":"..\\src"}